概述 
=======================

本文将为您介绍Sequence的相关概念和支持的类型。

PolarDB-X全局唯一数字序列（64位数字，对应MySQL中Signed BIGINT类型，以下简称为Sequence）的主要目标是为了生成全局唯一和有序递增的数字序列，常用于主键列、唯一索引列等值的生成。

基本概念 
-------------------------

了解以下概念，将帮助您更好地选用Sequence类型：

* 连续：如果本次取值为n，下一次取值一定是n + 1，则是连续的；如果下一次取值不能保证为n + 1，则是非连续的；

* 单调递增：如果本次取值为n，下一次取值一定是一个比n大的数，则是单调递增的；

* 单点：存在单点故障风险；

* 宏观上单调递增，微观上非单调递增：类似于`1、3、2、4、5、7、6、8、......`这样的序列，这个序列从宏观是看是递增的，微观上非单调递增。

* 单元化能力：能够跨实例或跨库分配全局唯一数字序列。




用法 
-----------------------

PolarDB-X中的Sequence主要有两类用法：

* 显式Sequence：通过Sequence DDL语法创建和维护，可以独立使用；通过`select seq.nextval`获取序列值，`seq` 是具体Sequence的名字。

* 隐式Sequence，在为主键定义AUTO_INCREMENT后，用于自动填充主键，由PolarDB-X自动维护。




支持的Sequence类型及其特性 
--------------------------------------

PolarDB-X目前共支持如下4种Sequence类型：


| 类型（缩写）                        | 全局唯一 | 连续 | 单调递增             | 同一连接内单调递增 | 非单点 | 数据类型       | 可读性 | 单元化能力 |
|:------------------------------|:-----|:---|:-----------------|:----------|:----|:-----------|:----|:------|
| **Group Sequence（GROUP）**     | 是    | 否  | 否                | 是         | 是   | 所有整型       | 好   | 否     |
| **单元化 Group Sequence（GROUP）** | 是    | 否  | 否                | 是         | 是   | 所有整型       | 好   | 是     |
| **Time-based Sequence（TIME）** | 是    | 否  | 宏观上单调递增，微观上非单调递增 | 是         | 是   | 仅支持 BIGINT | 差   | 否     |
| **Simple Sequence（SIMPLE）**   | 是    | 是  | 是                | 是         | 否   | 所有整型       | 好   | 否     |



**Group Sequence（GROUP，默认使用）** 

全局唯一的Sequence，产生的值是自然数序列，但是不保证连续和单调递增。如果未指定Sequence类型，PolarDB-X默认使用Group Sequence。

实现原理：采用多个节点产生值来保证高可用，每次取出一段值，如果该段值没有取完（比如连接断掉等情形），就会产生跳跃段。

* 优点：全局唯一，不会产生单点问题，性能非常好。

* 缺点：产生的序列不连续，可能会有跳跃段；不会严格从起始值开始取值；不能循环。




**单元化 Group Sequence（GROUP）** 

以Group Sequence为基础，扩展了单元化能力，能够跨实例或跨库实现全局唯一，但同样不保证连续和单调自增。当单元化 Group Sequence仅配置一个单元时，等价于普通的Group Sequence。

* 优点：具备Group Sequence的所有优点，且扩展了单元化能力。

* 缺点：产生的序列不连续，可能会有跳跃段；不会严格从起始值开始取值；不能循环。




基本原理与Group Sequence相同；通过扩展参数选项，支持自定义单元数量和单元索引：

* 单元数量决定了单元化 Group Sequence的全局唯一数字序列分配空间；

* 每个单元（由单元索引指定）占用全局唯一数字序列分配空间中的一个子集；

* 不同单元（指定了不同的单元索引）占用的子集之间不重叠（即不会分配相同的Sequence值）；

* 属于同一个全局唯一数字序列分配空间的每个单元化Group Sequence，必须指定相同的单元数量和不同的单元索引。



**说明**

单元化 Group Sequence从以下版本开始提供支持：

* V5.2：V5.2.7-1606682（2018.4.27）

* V5.3：V5.3.3-1670435（2018.8.15）




**Time-based Sequence（TIME）** 

基于时间戳+节点编号+序列号组合而成的一种Sequence，保证全局唯一和宏观自增；这种Sequence值的更新不依赖于数据库，也不需要持久化到数据库，仅在数据库中保留名称和类型信息，性能很好；产生的是类似于`776668092129345536、776668098018148352、776668111578333184、776668114812141568、......`这样的序列值。

* 优点：全局唯一、性能很好。

* 缺点：产生的序列不连续，起始值、步长、最大值、是否循环这些参数对于Time-based Sequence无意义。



**说明**

* 用于表中自增列时，必须使用BIGINT类型；

* Time-based Sequence从以下版本开始提供支持：
  * V5.2：V5.2.8-15432885（2018.11.27）
  
  * V5.3：V5.3.6-15439241（2018.11.29）
  

  



**Simple Sequence（SIMPLE）**

仅Simple Sequence支持自定义步长、最大值和循环/非循环利用。

* 优点：全局唯一、连续、单调递增，并具备最大值和循环利用等特性。

* 缺点：单点，性能较差，存在瓶颈，需要谨慎使用。




每产生一个值都要进行一次持久化操作。

使用场景 
-------------------------

这几种Sequence都保证全局唯一，均可以应用在主键列和唯一索引列。

* 大部分场景下建议选用Group Sequence；

* 如果有跨实例或跨库分配全局唯一数字序列的需求，可以选用单元化Group Sequence；

* 如果业务上能接受整体趋势上的宏观自增，不介意微观上的不保证自增，且不想依赖数据库的分配机制，则Time-based Sequence可能是合适的选择；

* 如果业务强依赖连续的Sequence值，此时只能使用Simple Sequence（注意Simple Sequence的性能问题）。




以创建一个起始值是100000，步长为1的Sequence为例说明。

* 如果采用 **Simple Sequence** ，则会严格产生`100000、100001、100002、100003、100004、.....、200000、200001、200002、200003、......`这样的序列（全局唯一、连续、单调递增）。Simple Sequence 会保证持久化，即使发生单点问题，服务重启后依然会在断点继续产生 Sequence 值，中间不会产生跳跃段。Simple Sequence 的机理是每产生一个值都要进行一次持久化操作，因此性能并不是很好。

* 如果采用 **Group Sequence** 或 **单元化 Group Sequence** ，产生的序列有可能是`200001、200002、200003、200004、100001、100002、100003、......`这样的序列。



**说明**

* Group Sequence起始值并不会严格从设定的参数（本例中是100000）开始，但保证比该参数大。本例中是从200001开始取值的。

* Group Sequence保证全局唯一，但是会有跳跃段。比如 roup Sequence的某个节点失效，或者某个连接只取了一部分值，然后该连接被关闭了，都会产生跳跃段。该例中200004和100001之间产生了跳跃段。

* 单元化Group Sequence跨实例或跨库的全局唯一性，必须通过指定相同的单元数量和不同的单元索引来保证。



